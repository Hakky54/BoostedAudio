<!DOCTYPE html>
<html>
<head>
    <title>Appel audio WebRTC</title>
</head>
<body>
<h1>Appel audio WebRTC</h1>
<audio id="localAudio" autoplay></audio>
<audio id="remoteAudio" autoplay></audio>
<button onclick="startCall()">Démarrer l'appel</button>
<button onclick="endCall()">Terminer l'appel</button>

<script>
    // Connexion WebSocket
    const socket = new WebSocket('ws://localhost:8080/');

    let localStream, remoteStream;
    let peerConnection;

    // Événement de connexion réussie
    socket.onopen = () => {
        console.log('Connecté au serveur WebSocket.');
    };

    // Événement de réception de message
    socket.onmessage = async (event) => {
        // Gérer les messages entrants ici (offres SDP, réponses SDP, candidats ICE, etc.)
        const message = JSON.parse(event.data);
        if (message.type === 'offer') {
            await handleOffer(message);
        } else if (message.type === 'answer') {
            await handleAnswer(message);
        } else if (message.type === 'candidate') {
            await handleCandidate(message);
        }
    };

    // Fonction pour envoyer des messages au serveur WebSocket
    function sendMessage(message) {
        socket.send(JSON.stringify(message));
    }

    // Fonction pour démarrer l'appel audio
    async function startCall() {
        try {
            // Obtenir l'accès au flux audio local (microphone)
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            // Afficher le flux audio local dans l'élément audio local
            document.getElementById('localAudio').srcObject = localStream;

            // Créer une connexion Peer
            peerConnection = new RTCPeerConnection();

            // Ajouter le flux audio local à la connexion Peer
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // Gérer le flux audio distant lorsque la connexion est établie
            peerConnection.ontrack = event => {
                remoteStream = event.streams[0];
                document.getElementById('remoteAudio').srcObject = remoteStream;
            };

            // Gérer la connexion ICE (Interactive Connectivity Establishment)
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    sendMessage({
                        type: 'candidate',
                        candidate: event.candidate
                    });
                }
            };

            // Créer une offre SDP (Session Description Protocol)
            const offer = await peerConnection.createOffer();

            // Définir l'offre locale comme description locale
            await peerConnection.setLocalDescription(offer);

            // Envoyer l'offre SDP au serveur WebSocket
            sendMessage({
                type: 'offer',
                offer: offer
            });
        } catch (error) {
            console.error('Erreur lors du démarrage de l\'appel audio:', error);
        }
    }

    // Fonction pour gérer une offre SDP reçue du serveur
    async function handleOffer(message) {
        try {
            // Configurer la connexion Peer avec l'offre SDP reçue
            peerConnection = new RTCPeerConnection();

            // Ajouter le flux audio local à la connexion Peer
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // Gérer le flux audio distant lorsque la connexion est établie
            peerConnection.ontrack = event => {
                remoteStream = event.streams[0];
                document.getElementById('remoteAudio').srcObject = remoteStream;
            };

            // Gérer la connexion ICE (Interactive Connectivity Establishment)
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    sendMessage({
                        type: 'candidate',
                        candidate: event.candidate
                    });
                }
            };

            // Définir l'offre distante comme description distante
            await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));

            // Créer une réponse SDP (Session Description Protocol)
            const answer = await peerConnection.createAnswer();

            // Définir la réponse locale comme description locale
            await peerConnection.setLocalDescription(answer);

            // Envoyer la réponse SDP au serveur WebSocket
            sendMessage({
                type: 'answer',
                answer: answer
            });
        } catch (error) {
            console.error('Erreur lors de la gestion de l\'offre SDP:', error);
        }
    }

    // Fonction pour gérer une réponse SDP reçue du serveur
    async function handleAnswer(message) {
        try {
            // Définir la réponse distante comme description distante
            await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
        } catch (error) {
            console.error('Erreur lors de la gestion de la réponse SDP:', error);
        }
    }

    // Fonction pour gérer un candidat ICE reçu du serveur
    async function handleCandidate(message) {
        try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
        } catch (error) {
            console.error('Erreur lors de la gestion du candidat ICE:', error);
        }
    }

    // Fonction pour terminer l'appel audio
    function endCall() {
        // Fermer la connexion Peer
        if (peerConnection) {
            peerConnection.close();
        }

        // Arrêter le flux audio local et distant
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            document.getElementById('localAudio').srcObject = null;
        }

        if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
            document.getElementById('remoteAudio').srcObject = null;
        }

        // Fermer la connexion WebSocket
        socket.close();
    }
</script>
</body>
</html>
