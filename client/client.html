<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Communication audio via WebSocket</title>
</head>
<body>
<h1>Communication audio via WebSocket</h1>
<button id="startButton">Démarrer la communication</button>
<button id="stopButton">Arrêter la communication</button>
<div id="output"></div>

<script>
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const outputDiv = document.getElementById('output');

    let ws;
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let mediaRecorder;
    let audioChunks = [];
    let microphoneSource;

    async function startCommunication() {
        try {
            ws = new WebSocket('ws://127.0.0.1:8080/');

            // Établir la connexion WebSocket
            ws.onopen = function(event) {
                console.log('WebSocket connecté !');

                // Obtenir l'accès au microphone
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(function(stream) {
                        // Créer un nouvel enregistreur audio
                        const mediaRecorder = new MediaRecorder(stream);

                        // Démarrer l'enregistrement lorsque l'enregistreur est prêt
                        mediaRecorder.onstart = function() {
                            audioChunks = [];
                            console.log('START!');
                        };//d dqsdsq

                        var time = 100;
                        // Capturer les données audio pendant l'enregistrement
                        mediaRecorder.ondataavailable = function(event) {
                            console.log('DATA AVAILABLE!');
                            audioChunks.push(event.data);
                            console.log(event.data);
                            // Envoyer les données audio au serveur à chaque nouvel échantillon
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.send(event.data);
                            }
                            mediaRecorder.stop()
                            mediaRecorder.start(time);
                        };

                        // Démarrer le traitement audio en continu (sans limite de durée)

                        mediaRecorder.start(time);

                        // Connecter l'audioNode à la source audio (stream du microphone)
                        const microphoneSource = audioContext.createMediaStreamSource(stream);




                    })
                    .catch(function(error) {
                        console.error('Erreur lors de l\'accès au microphone:', error);
                    });


                ws.onmessage = function(event) {
                    // Récupérer les données audio reçues du serveur
                    const audioData = event.data;
                    // Jouer le son reçu du serveur
                    playAudioFromServer(audioData);
                };

                // Gérer les erreurs WebSocket
                ws.onerror = function(event) {
                    console.error('Erreur WebSocket:', event);
                };

                // Fermer la connexion WebSocket lorsque l'enregistrement est terminé
                ws.onclose = function(event) {
                    console.log('WebSocket déconnecté !');
                    if (mediaRecorder && mediaRecorder.state !== "inactive") {
                        mediaRecorder.stop();
                    }
                };
            };
        } catch (error) {
            console.error('Erreur lors de la connexion au serveur:', error);
        }
    }

    function initMediaRecorder() {

    }

    // Fonction pour jouer le son reçu du serveur
    function playAudioFromServer(audioData) {
        if (audioData instanceof Blob) {
            const reader = new FileReader();
            reader.onload = function() {
                const arrayBuffer = reader.result;
                audioContext.decodeAudioData(arrayBuffer, function(buffer) {
                    console.log(buffer)
                    const audioSource = audioContext.createBufferSource();
                    audioSource.buffer = buffer;
                    audioSource.connect(audioContext.destination);
                    audioSource.start();
                }, function(error) {
                    console.error('Erreur lors du décodage des données audio:', error);
                });
            };
            reader.readAsArrayBuffer(audioData);
        }
    }


    function copy(src)  {
        var dst = new ArrayBuffer(src.byteLength);
        new Uint8Array(dst).set(new Uint8Array(src));
        return dst;
    }


    function stopCommunication() {
        // Arrêter la capture audio
        if (mediaStream) {
            mediaStream.getTracks().forEach(track => track.stop());
        }

        // Fermer la connexion WebSocket
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.close();
        }

        outputDiv.textContent = 'Communication audio arrêtée.';
    }

    startButton.addEventListener('click', startCommunication);
    stopButton.addEventListener('click', stopCommunication);
</script>
</body>
</html>