<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            module: {
                exports: {
                    darkMode: 'media'
                }
            }
        }
    </script>
    <audio id="remoteAudio" muted autoplay></audio>
    <title>WebRTC Demo</title>
</head>
<body class="h-screen w-screen bg-center">
<div class="h-full w-full bg-center
bg-gradient-to-tr from-gray-950 to-blue-950"></div>
<div class="absolute inset-0 h-full w-full bg-center
bg-gradient-to-tl from-gray-950 to-blue-800/50 opcatiy-5"></div>
<div class="absolute inset-0 h-full w-full p-8 text-slate-200">
    <div class="bg-gray-700/50 p-6 rounded-lg shadow-2xl max-h-screen">
        <h1 class="text-2xl font-bold mb-4">Boosted Audio</h1>
        <div class="flex mb-6">
            <div class="w-1/3 pr-4">
                <label class="block text-sm font-medium mb-2">Main Volume</label>
                <input id="microphoneMaster" type="range" class="w-full ring-slate-800" min="-100" max="150">
            </div>
            <div class="w-1/3 px-2">
                <label class="block text-sm font-medium mb-2">Microphone Noise</label>
                <input id="microphoneNoise" type="range" class="w-full" min="0" max="100">
            </div>
            <div class="w-1/3 pl-4">
                <label class="block text-sm font-medium mb-2">Microphone Device</label>
                <select id="microphoneSelect"
                        class="w-full bg-gray-800 rounded px-3 py-2 focus:outline-none focus:ring hover:ring duration-300">
                </select>
            </div>
        </div>
        <h2 class="text-lg font-bold mb-4">User List</h2>

        <input id="panning-slider" type="range" min="-1" max="1" step="0.1" value="0">

        <div class="p-1 w-1/5 mb-4 relative">
            <input type="text"
                   class="w-full px-4 py-2 focus:ring hover:ring duration-300 bg-gray-800 text-gray-300 border-none rounded-full focus:outline-none"
                   placeholder="Recherche..." maxlength="20">
            <div class="absolute right-3 top-1/2 transform -translate-y-1/2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-300" viewBox="0 0 20 20"
                     fill="currentColor">
                    <path fill-rule="evenodd"
                          d="M14.833 13.392a8 8 0 1 0-1.44 1.44l5.334 5.333a1 1 0 0 0 1.5-1.333l-5.333-5.333zM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8z"/>
                </svg>
            </div>
        </div>


        <div id="users" class="overflow-auto
        sm:max-h-[5rem] md:max-h-[20rem] 2xl:sm:max-h-[30rem]
         min-h-0 bg-gray-700/40 p-2 rounded-lg bg-scroll grid gap-4 sm:grid-cols-1 md:grid-cols-3 lg:grid-cols-4">

            <div id="user" class="flex items-center bg-gray-800 p-4 rounded-lg">
                <!--https://cravatar.eu/avatar/SuperMax_8/512-->
                <img src="" alt="User 1" class="logo w-12 h-12 rounded-lg mr-4">
                <div class="flex-grow">
                    <p class="font-medium username"></p>
                    <input type="range" class="w-full mt-1">
                </div>
                <button class="ml-4 active:text-red-500 hover:text-red-300">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                         stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"/>
                    </svg>
                </button>
            </div>

        </div>
    </div>
</div>
<script>
    const servers = {
        iceServers: [
            {
                urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
            },
        ],
        iceCandidatePoolSize: 10,
    };

    const peerConnections = new Map();
    let micStream;
    let playerId;
    const params = new URLSearchParams(window.location.search);
    const ws = new WebSocket("ws://pyritemc.fr:8081/");
    const localMediaStream = new MediaStream();
    let audioContext;
    let gainNode;
    let source;

    // HTML elements
    const callButton = document.getElementById('callButton');
    const remoteAudio = document.getElementById('remoteAudio');
    const users = document.getElementById('users');
    const microphoneMaster = document.getElementById('microphoneMaster');
    const microphoneNoise = document.getElementById('microphoneNoise');
    const microphoneSelect = document.getElementById('microphoneSelect');

    let userTemplate;

    let panner;


    // Setup html user element
    const user = document.getElementById("user")
    userTemplate = user.outerHTML
    user.remove()


    ws.onopen = async () => {
        console.log("WebSocket Open")

        if (!params.has("token") || !params.has("playerId")) {
            console.log("Without token or playerId this will not connected to the websocket")
            return
        }

        playerId = params.get("playerId")

        sendTrustPacket()
        await setupAudioSystem()


        ws.onmessage = message => {
            handlePackets(message.data)
        }

        setInterval(() => {
            console.log("States:")
            peerConnections.forEach((pc, k) => {
                console.log("- State: " + pc.pc.connectionState)
            })
        }, 3000)

    }

    async function handlePacket(type, packet) {
        /*    console.log("----------RECEIVING PACKET----------")
            console.log(JSON.stringify(packet))
            console.log("------------------------------------")*/
        let from;
        let to;
        let pc
        switch (type) {
            case "AddPeerPacket":
                from = packet.from;
                to = packet.to;
                switch (packet.rtcDesc.type) {
                    // Packet action from server
                    case "createoffer":
                        pc = createPeerConnection(from)
                        const offer = await pc.createOffer()
                        await pc.setLocalDescription(offer)

                        const offerPacket = [
                            {
                                "type": "AddPeerPacket",
                                "value": {
                                    "from": playerId,
                                    "to": from,
                                    "rtcDesc": {
                                        "type": offer.type,
                                        "sdp": offer.sdp,
                                    }
                                }
                            }
                        ]
                        /*console.log("Offer: " + JSON.stringify(offerPacket))*/

                        /*console.log("Creating offer")*/
                        ws.send(JSON.stringify(offerPacket))
                        break
                    // Packet action from other user, check by server
                    // Receive offer
                    case "offer":
                        pc = await createPeerConnection(from)
                        const desc = new RTCSessionDescription(packet.rtcDesc);
                        await pc.setRemoteDescription(desc)

                        const answer = await pc.createAnswer()
                        await pc.setLocalDescription(answer)

                        const answerPacket = [
                            {
                                "type": "AddPeerPacket",
                                "value": {
                                    "from": to,
                                    "to": from,
                                    "rtcDesc": {
                                        "type": answer.type,
                                        "sdp": answer.sdp,
                                    }
                                }
                            }
                        ]

                        ws.send(JSON.stringify(answerPacket))
                        /*console.log("Receive OFFER, Sending answer")*/
                        break
                    // Packet action from other user, check by server
                    // Receive answer
                    case "answer":
                        pc = peerConnections.get(from).pc
                        await pc.setRemoteDescription(new RTCSessionDescription(packet.rtcDesc))
                        /*console.log("Receive answer")*/
                        break
                }
                break
            case "RTCIcePacket":
                from = packet.from;
                to = packet.to;
                pc = peerConnections.get(from).pc
                const iceCandidate = new RTCIceCandidate({
                    "candidate": packet.candidate.candidate,
                    "sdpMid": packet.candidate.sdpMid,
                    "sdpMLineIndex": packet.candidate.sdpMLineIndex
                });

                const candidate = new RTCIceCandidate(iceCandidate);

                pc.addIceCandidate(candidate)
                    .catch((error) => {
                        console.error("Erreur with ICE candidate set : ", error);
                    });

                /*console.log("ICE Candidate set")*/
                break
            case "RemovePeerPacket":
                const playerToRemoveId = packet.playerToRemove;
                closePeerConnection(peerConnections.get(playerToRemoveId))
                peerConnections.delete(playerToRemoveId)
                break
            default:
                break;
        }
    }

    function fetchDataWithCORSAnywhere(url) {
        const corsAnywhereUrl = 'https://cors-anywhere.herokuapp.com/';

        return fetch(corsAnywhereUrl + url, {
            method: 'GET',
            headers: {
                'Origin': '',  // Laissez l'en-tête Origin vide pour que CORS Anywhere fonctionne
            },
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            });
    }

    async function showUser(peerObj) {
        const url = 'https://corsproxy.io/?' + encodeURIComponent('https://minecraft-api.com/api/pseudo/' + peerObj.playerId + '/json');
        const response = await fetch(url);
        const userName = JSON.parse(await response.text()).pseudo;

        const element = htmlStringToElement(userTemplate)
        const nameElement = element.getElementsByClassName("username").item(0)
        const logoElement = element.getElementsByClassName("logo").item(0)

        element.id = userName

        nameElement.textContent = userName;
        logoElement.src = "http://cravatar.eu/avatar/" + userName + "/512.png"

        peerObj.element = element;

        users.insertAdjacentElement("beforeend", element);
    }

    function createPeerConnection(from) {
        let pc = new RTCPeerConnection(servers)
        if (peerConnections.has(from)) closePeerConnection(peerConnections.get(from))

        const tracks = [];
        const panner = audioContext.createStereoPanner();

        const connection = {
            pc: pc,
            tracks: tracks,
            panner: panner,
            playerId: from,
            htmlElement: null
        }

        showUser(connection)

        peerConnections.set(from, connection)


        pc.ontrack = event => {
            if (event.track.kind === 'audio') {
                const track = event.track;

                localMediaStream.addTrack(track)

                source = audioContext.createMediaStreamSource(localMediaStream);
                source.connect(panner);
                source.connect(gainNode);
                panner.connect(audioContext.destination);

                const panningSlider = document.getElementById('panning-slider');
                panningSlider.addEventListener('input', () => {
                    panner.pan.value = parseFloat(panningSlider.value);
                });

                tracks.push(track)
            }
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                let to = null;
                peerConnections.forEach((pcc, id) => {
                    if (pcc.pc === pc) to = id
                })
                const packet = [
                    {
                        "type": "RTCIcePacket",
                        "value": {
                            "from": playerId,
                            "to": to,
                            type: 'candidate',
                            candidate: event.candidate
                        }
                    }
                ]

                ws.send(JSON.stringify(packet));
                // console.log("Sending ICE candidate")
            }
        };

        micStream.getTracks().forEach((track) => {
            pc.addTrack(track, micStream);
        });

        return pc;
    }

    function closePeerConnection(peerConnectionContainer) {
        for (const track of peerConnectionContainer.tracks) {
            localMediaStream.removeTrack(track)
        }
        peerConnectionContainer.pc.close()
    }

    function htmlStringToElement(htmlString) {
        const tempContainer = document.createElement("div");
        tempContainer.innerHTML = htmlString;
        return tempContainer.firstElementChild;
    }

    function sendTrustPacket() {
        const trustPacket = [{
            "type": "TrustPacket",
            "value": {
                "token": params.get("token")
            }
        }]

        ws.send(JSON.stringify(trustPacket))
    }

    async function populateMicrophoneOptions() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputDevices = devices.filter(device => device.kind === "audioinput");

            microphoneSelect.innerHTML = ""; // Clear previous options

            audioInputDevices.forEach(device => {
                const option = document.createElement("option");
                option.value = device.deviceId;
                option.textContent = device.label || `Microphone ${microphoneSelect.childElementCount + 1}`;
                microphoneSelect.appendChild(option);
            });
        } catch (error) {
            console.error("Error populating microphone options:", error);
        }
    }

    async function setupAudioSystem() {
        //-Compatibility chrome-
        remoteAudio.srcObject = localMediaStream;
        //----------------------


        micStream = await navigator.mediaDevices.getUserMedia({audio: true});

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        gainNode.connect(audioContext.destination);

        gainNode.gain.value = 1;
        microphoneMaster.value = 100;
        microphoneMaster.addEventListener('input', function () {
            const volume = parseFloat(this.value) / 100;
            gainNode.gain.value = volume;
            console.log(volume)
        });

        await populateMicrophoneOptions();

        microphoneSelect.addEventListener("change", async () => {
            try {
                const selectedDeviceId = microphoneSelect.value;
                const constraints = {audio: {deviceId: selectedDeviceId}};
                micStream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (error) {
                console.error("Error getting selected microphone stream:", error);
            }
        });
    }

    async function handlePackets(packetList) {
        const jsonArray = JSON.parse(packetList);

        for (const packetObject of jsonArray) {
            const type = packetObject.type;
            const value = packetObject.value;
            await handlePacket(type, value)
        }

    }

</script>
</body>
</html>