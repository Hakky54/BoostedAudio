<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            module: {
                exports: {
                    darkMode: 'media'
                }
            }
        }
    </script>
    <title>BoostedAudio</title>
</head>
<body class="h-screen w-screen bg-center">
<div class="h-full w-full bg-center
bg-gradient-to-tr from-gray-950 to-blue-950"></div>
<div class="absolute inset-0 h-full w-full bg-center
bg-gradient-to-tl from-gray-950 to-blue-800/50 opcatiy-5"></div>
<div class="absolute inset-0 h-full w-full p-8 text-slate-200">
    <div class="bg-gray-700/50 p-6 rounded-lg shadow-2xl max-h-screen">
        <h1 class="text-2xl font-bold mb-4">Boosted Audio</h1>
        <div class="flex mb-6 items-center">
            <div class="w-1/3 pr-4">
                <label class="block text-sm font-medium mb-2">Main Volume</label>
                <input id="master" type="range" class="w-full ring-slate-800" min="0" max="150">
            </div>
            <div class="w-1/3 px-2">
                <label class="block text-sm font-medium mb-2">Microphone Noise</label>
                <input id="microphoneNoise" type="range" class="w-full" min="0" max="100">
            </div>
            <div class="w-1/3 pl-4">
                <label class="block text-sm font-medium mb-2">Microphone Device</label>
                <select id="microphoneSelect"
                        class="w-full bg-gray-800 rounded px-3 py-2 focus:outline-none focus:ring hover:ring duration-300">
                </select>
            </div>
        </div>

        <h2 class="text-lg font-bold mb-4">User List</h2>

        <div class="p-1 w-1/5 mb-4 relative">
            <input type="text"
                   class="w-full px-4 py-2 focus:ring hover:ring duration-300 bg-gray-800 text-gray-300 border-none rounded-full focus:outline-none"
                   placeholder="Recherche..." maxlength="20">
            <div class="absolute right-3 top-1/2 transform -translate-y-1/2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-300" viewBox="0 0 20 20"
                     fill="currentColor">
                    <path fill-rule="evenodd"
                          d="M14.833 13.392a8 8 0 1 0-1.44 1.44l5.334 5.333a1 1 0 0 0 1.5-1.333l-5.333-5.333zM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8z"/>
                </svg>
            </div>
        </div>


        <div id="users" class="overflow-auto
        sm:max-h-[5rem] md:max-h-[20rem] 2xl:sm:max-h-[30rem]
         min-h-0 bg-gray-700/40 p-2 rounded-lg bg-scroll grid gap-4 sm:grid-cols-1 md:grid-cols-3 lg:grid-cols-4">

            <div id="user"
                 class="flex items-center bg-gray-800 p-4 rounded-lg focus:outline-none focus:ring hover:ring duration-300">
                <!--https://cravatar.eu/avatar/SuperMax_8/512-->
                <img src="" alt="User 1" class="logo w-12 h-12 rounded-lg mr-4">
                <div class="flex-grow">
                    <p class="font-medium username"></p>
                    <input type="range" class="user-volume w-full mt-1" min="0" max="150">
                </div>
                <button class="ml-4 active:text-red-500 hover:text-red-300">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                         stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"/>
                    </svg>
                </button>
            </div>

        </div>
    </div>
</div>
<script>
    const servers = {
        iceServers: [
            {
                urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
            },
        ],
        iceCandidatePoolSize: 10,
    };

    const peerConnections = new Map();
    let micStream;
    let playerId;
    const params = new URLSearchParams(window.location.search);
    const wsIP = "%WS_IP%";
    let ws;
    let audioContext;
    let masterVolume = 1;

    let clientLoc;

    let maxDistance;
    let rolloffFactor;
    let refDistance;
    let distanceModel;


    // HTML elements
    const users = document.getElementById('users');
    const microphoneMaster = document.getElementById('master');
    const microphoneNoise = document.getElementById('microphoneNoise');
    const microphoneSelect = document.getElementById('microphoneSelect');

    let userTemplate;


    let isOpen = false;

    // Setup html user element
    const user = document.getElementById("user")
    userTemplate = user.outerHTML
    user.remove()

    let onopen;

    ws = new WebSocket(wsIP);

    const f = () => {
        const intervalId = setInterval(() => {
            if (isOpen === true) {
                clearInterval(intervalId)
                console.log("Connection etablished")
                return;
            }
            console.log("Reset WebSocket")
            ws.close()
            ws = new WebSocket(wsIP);
            ws.onopen = onopen;
        }, 3500)
    }
    setTimeout(f, 2000)

    onopen = async () => {
        isOpen = true;
        console.log("WebSocket Open")

        await setupAudioSystem()

        if (!params.has("token") || !params.has("playerId")) {
            console.log("Without token or playerId this will not connected to the websocket")
            return
        }

        playerId = params.get("playerId")

        sendTrustPacket()

        ws.onmessage = message => {
            handlePackets(message.data)
        }
        ws.onclose = () => {
            console.log("WebSocket closed :!")
        }

        setInterval(() => {
            console.log("States:")
            peerConnections.forEach((pc, k) => {
                console.log("- State: " + pc.pc.connectionState)
            })
        }, 3000)
    }
    ws.onopen = onopen;

    async function handlePacket(type, packet) {
        /*    console.log("----------RECEIVING PACKET----------")
            console.log(JSON.stringify(packet))
            console.log("------------------------------------")*/
        let from;
        let to;
        let pc
        switch (type) {
            case "AddPeerPacket":
                from = packet.from;
                to = packet.to;
                switch (packet.rtcDesc.type) {
                    // Packet action from server
                    case "createoffer":
                        pc = await createPeerConnection(from)
                        const offer = await pc.createOffer()
                        await pc.setLocalDescription(offer)

                        const offerPacket = [
                            {
                                "type": "AddPeerPacket",
                                "value": {
                                    "from": playerId,
                                    "to": from,
                                    "rtcDesc": {
                                        "type": offer.type,
                                        "sdp": offer.sdp,
                                    }
                                }
                            }
                        ]
                        /*console.log("Offer: " + JSON.stringify(offerPacket))*/

                        /*console.log("Creating offer")*/
                        ws.send(JSON.stringify(offerPacket))
                        break
                    // Packet action from other user, check by server
                    // Receive offer
                    case "offer":
                        pc = await createPeerConnection(from)
                        const desc = new RTCSessionDescription(packet.rtcDesc);
                        await pc.setRemoteDescription(desc)

                        const answer = await pc.createAnswer()
                        await pc.setLocalDescription(answer)

                        const answerPacket = [
                            {
                                "type": "AddPeerPacket",
                                "value": {
                                    "from": to,
                                    "to": from,
                                    "rtcDesc": {
                                        "type": answer.type,
                                        "sdp": answer.sdp,
                                    }
                                }
                            }
                        ]

                        ws.send(JSON.stringify(answerPacket))
                        /*console.log("Receive OFFER, Sending answer")*/
                        break
                    // Packet action from other user, check by server
                    // Receive answer
                    case "answer":
                        pc = peerConnections.get(from).pc
                        await pc.setRemoteDescription(new RTCSessionDescription(packet.rtcDesc))
                        /*console.log("Receive answer")*/
                        break
                }
                break
            case "RTCIcePacket":
                from = packet.from;
                to = packet.to;
                pc = peerConnections.get(from).pc
                const iceCandidate = new RTCIceCandidate({
                    "candidate": packet.candidate.candidate,
                    "sdpMid": packet.candidate.sdpMid,
                    "sdpMLineIndex": packet.candidate.sdpMLineIndex
                });

                const candidate = new RTCIceCandidate(iceCandidate);

                pc.addIceCandidate(candidate)
                    .catch((error) => {
                        console.error("Erreur with ICE candidate set : ", error);
                    });

                /*console.log("ICE Candidate set")*/
                break
            case "RemovePeerPacket":
                const playerToRemoveId = packet.playerToRemove;
                closePeerConnection(peerConnections.get(playerToRemoveId))
                break
            case "UpdateVocalPositionsPacket":
                // Parse clientloc
                clientLoc = packet.clientLoc;
                // Parse peers info
                const players = packet.playersAround;
                const map = new Map();
                for (const key in players) {
                    if (players.hasOwnProperty(key)) map.set(key, players[key]);
                }

                peerConnections.forEach((peerObj, uuid) => {
                    peerObj.loc = map.get(uuid)
                    spatializeAudio(peerObj.panner, peerObj.loc)
                })
                break
            case "TrustPacket":
                const serverInfo = packet.serverInfo;
                maxDistance = serverInfo.maxDistance;
                rolloffFactor = serverInfo.rolloffFactor;
                refDistance = serverInfo.refDistance;
                distanceModel = serverInfo.distanceModel;
                console.log("ServerInfo set")
                break;
            default:
                break;
        }
    }

    function showUser(peerObj) {
        return new Promise(async (resolve, reject) => {
            const url = 'https://corsproxy.io/?' + encodeURIComponent('https://minecraft-api.com/api/pseudo/' + peerObj.playerId + '/json');
            const response = await fetch(url);
            const userName = JSON.parse(await response.text()).pseudo;

            const element = htmlStringToElement(userTemplate)
            const nameElement = element.getElementsByClassName("username").item(0)
            const logoElement = element.getElementsByClassName("logo").item(0)

            element.id = peerObj.playerId

            nameElement.textContent = userName;
            logoElement.src = "https://cravatar.eu/avatar/" + userName + "/512.png"

            peerObj.element = element;

            users.insertAdjacentElement("beforeend", element);
            resolve()
        })
    }

    function spatializeAudio(panner, peerLocation) {
        if (peerLocation == null) return
        // Calc peer loc relative to the client
        const x = peerLocation.x - clientLoc.x;
        const y = peerLocation.y - clientLoc.y;
        const z = peerLocation.z - clientLoc.z;

        // Calc yaw
        const yaw = degrees_to_radians(-clientLoc.yaw)

        // Rotate
        const newX = x * Math.cos(yaw) - z * Math.sin(yaw);
        const newZ = x * Math.sin(yaw) + z * Math.cos(yaw);

        // Set the values
        panner.positionX.value = newX
        panner.positionY.value = y
        panner.positionZ.value = newZ

        //panner.setPosition(newX, y, newZ);
    }

    function degrees_to_radians(degrees) {
        const pi = Math.PI;
        return degrees * (pi / 180);
    }

    async function createPeerConnection(from) {
        console.log("New RTCPeerConnection")
        let pc = new RTCPeerConnection(servers)
        if (peerConnections.has(from)) closePeerConnection(peerConnections.get(from))

        // Init var
        const panner = new PannerNode(audioContext, {
            panningModel: "HRTF",
            distanceModel: distanceModel,
            refDistance: Math.max(refDistance, 0.1),
            rolloffFactor: rolloffFactor,
            coneInnerAngle: 40,
            coneOuterAngle: 30,
            coneOuterGain: 0.4,
        });

        const gain = audioContext.createGain();

        const mediaStreamTrack = new MediaStream();

        const connection = {
            pc: pc,
            panner: panner,
            gain: gain,
            gainValue: 1,
            playerId: from,
            mute: false,
            loc: null,
            element: null
        }

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                let to = null;
                peerConnections.forEach((pcc, id) => {
                    if (pcc.pc === pc) to = id
                })
                const packet = [
                    {
                        "type": "RTCIcePacket",
                        "value": {
                            "from": playerId,
                            "to": to,
                            type: 'candidate',
                            candidate: event.candidate
                        }
                    }
                ]

                ws.send(JSON.stringify(packet));
                console.log("Sending ICE candidate")
            }
        }
        peerConnections.set(from, connection)

        pc.ontrack = event => {
            if (event.track.kind === 'audio') {
                console.log("Track set")
                const track = event.track;

                mediaStreamTrack.addTrack(track)
                // Connecting things
                const source = audioContext.createMediaStreamSource(mediaStreamTrack);
                source.connect(panner)
                panner.connect(gain)
                gain.connect(audioContext.destination)
                gain.gain.value = 1;

                // We use a dummy audio muted, because of a bug in chrome https://bugs.chromium.org/p/chromium/issues/detail?id=933677
                const dummyAudio = new Audio();
                dummyAudio.muted = true;
                dummyAudio.srcObject = mediaStreamTrack;
            }
        }

        micStream.getTracks().forEach((track) => {
            pc.addTrack(track, micStream);
        });

        async function userThing() {
            // Show user
            await showUser(connection)

            // Setup user bar
            const userVolume = connection.element.getElementsByClassName("user-volume").item(0);
            gain.gain.value = 1;
            userVolume.value = 100;
            userVolume.addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value) / 100;
                connection.gainValue = volume;
                gain.gain.value = volume * masterVolume;
            });
        }

        userThing()

        return pc;
    }

    function closePeerConnection(peerConnectionContainer) {
        if (peerConnectionContainer == null) return
        peerConnectionContainer.pc.close()
        if (peerConnectionContainer.element != null) peerConnectionContainer.element.remove()
        peerConnections.delete(peerConnectionContainer.playerId)
    }

    function htmlStringToElement(htmlString) {
        const tempContainer = document.createElement("div");
        tempContainer.innerHTML = htmlString;
        return tempContainer.firstElementChild;
    }

    function sendTrustPacket() {
        const trustPacket = [{
            "type": "TrustPacket",
            "value": {
                "token": params.get("token")
            }
        }]

        ws.send(JSON.stringify(trustPacket))
    }

    async function populateMicrophoneOptions() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputDevices = devices.filter(device => device.kind === "audioinput");

            microphoneSelect.innerHTML = ""; // Clear previous options

            audioInputDevices.forEach(device => {
                const option = document.createElement("option");
                option.value = device.deviceId;
                option.textContent = device.label || `Microphone ${microphoneSelect.childElementCount + 1}`;
                microphoneSelect.appendChild(option);
            });
        } catch (error) {
            console.error("Error populating microphone options:", error);
        }
    }

    async function setupAudioSystem() {
        micStream = await navigator.mediaDevices.getUserMedia({audio: true});

        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        microphoneMaster.value = 100;
        microphoneMaster.addEventListener('input', function () {
            masterVolume = parseFloat(this.value) / 100;
            peerConnections.forEach((peerObj, id) => {
                peerObj.gain.gain.value = peerObj.gainValue * masterVolume;
            })
        });

        await populateMicrophoneOptions();

        microphoneSelect.addEventListener("change", async () => {
            try {
                const selectedDeviceId = microphoneSelect.value;
                console.log("New device selected: " + selectedDeviceId)
                const constraints = {audio: {deviceId: selectedDeviceId}};
                micStream = await navigator.mediaDevices.getUserMedia(constraints);

                for (const peerObj in peerConnections.values()) {
                    const pc = peerObj.pc;
                    pc.getSenders().forEach(sender => {
                        pc.removeTrack(sender)
                    })
                    micStream.getTracks().forEach((track) => {
                        pc.addTrack(track, micStream);
                    });
                    pc.getSenders().forEach(sender => {
                        console.log(sender)
                    })
                }
            } catch (error) {
                console.error("Error getting selected microphone stream:", error);
            }
        });
    }

    async function handlePackets(packetList) {
        const jsonArray = JSON.parse(packetList);

        for (const packetObject of jsonArray) {
            const type = packetObject.type;
            const value = packetObject.value;
            await handlePacket(type, value)
        }

    }

</script>
</body>
</html>